



15.单链表：线性表链式存储
   通过一组任意的存储单元来存储线性表中的数据元素
   为了建立数据之间的线性关系，对每个链表节点，除存放元素自身的信息外，还需要存放一个指向其后继的指针
16.通常用头指针来标识一个单链表，如单链表L，头指针为NULL时表示一个空表
   在单链表第一个结点之前附加一个结点，称为头结点，头结点的数据域可以不设任何信息，也可以记录表长等
   L-->|///| *--|->  | a1 | *--|-> | a2 | *--|-> ....
17.:头节点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头节点是带头结点的链表中的第一个结点
18.引入头结点之后
  (1)由于第一个数据结点的位置被存放在头结点的指针域中,因此在链表的的第一个位置上的操作和在表的其他位置上的操作一致
  (2)无论链表是否为空,其头指针都是非空指针(空表中头结点的指针域为空)因此空表和飞控表的处理也得到了统一
19.循环单链表
表尾结点指针*r的next域指向L，故表中没有指针域为NULL的结点
判断循环单链表上是否为空的条件是头结点的指针是否等于头指针
20.循环双链表
   (1)循环双链表中，头结点的prior指针指向表尾结点
   (2)在循环双链表L中，若某结点*p为尾结点时,p->next==L;
   (3)当循环双链表为空时，其头结点的prior域和next域都等于L
21.静态链表
   (1)借助数组来描述线性表的链式存储结构
   (2)也有数据域data和指针域next,这里的指针时结点的相对地址(数组下标)，又称游标
   (3)和顺序表一样,静态链表也要预先分配一块连续的内存空间
22.静态链表以next==-1作为其结束的标志
   静态链表的插入、删除操作与动态链表相同,只需要修改指针,不需要移动元素
   静态链表没有单链表使用方便,但是在不支持指针的情况下,是一种奇妙的设计
23.顺序表和链表的比较
1.存取(读写)方式
   (1)顺序表可以顺序存取,也可以随机存取,链表只能从表头顺序存取元素。
   (2)采用顺序存储时,逻辑上相邻的元素,对应的物理存储位置也相邻
2.采用链式存储时,逻辑上相邻的元素,物理存储位置不一定相邻,对应的逻辑关系是通过指针链接来表示的
3.查找、插入和删除操作
   按值查找,顺序表无序时,两者的时间复杂度均为O(n);顺序表有序时,可以采用折半查找,时间复杂度为O(logn)
4.空间分配
   (1)顺序存储在静态存储分配情形下,一旦存储空间装满就不能扩充,若再加入新元素,则会出现内存溢出,
   因此需要预先分配足够大的存储空间,但预先分配过大,可能会导致顺序表后部大量闲置;预先分配过小,又会造成溢出
   (2)采用动态存储分配虽然存储空间可以扩充,但需要移动大量元素,导致操作效率低,而且若内存中没有
   更大块的连续存储空间,则会导致分配失败
   (3)链式存储的结点空间只在需要时申请分配,只要内存有空间就可以分配,操作灵活且高效
5.如何选取存储结构
   (1)基于存储的考虑
   难以估计线性表的长度或存储规模时,不宜采用顺序表;链表不用事先估计存储规模,
   但链表的存储密度低
   (2)基于运算的考虑
   顺序表中方位ai的时间复杂度是O(1),而链表是O(n),因此若常做按序号访问数据元素的操作,顺序表优于链表
   在顺序表中进行插入、删除操作时,平均移动表中一半的元素,当数据元素的信息量较大且表长时,链表优于顺序表
   虽然链表查找插入位置会费时
   (3)基于环境的考虑
   顺序表容易实现,任何高级语言中都有数组类型;而链表的生死线是基于指针的

单选题
1.B
2.B
3.C
4.D
5.B  A 删除元素链表不用移动很多元素 效率高 在最后一个元素后插入一个元素,顺序表效率高(不考虑内存不够)
6.C
7.B  D 数组排序的时间复杂度是O(nlogn)+插入的复杂度O(n)=O(nlogn)
8.A  C 插到链表最后面的时间复杂度是O(n),因为要找到这个元素的时间复杂度是O(n)
9.B C? 增加头结点的目的是方便运算
10.B
11.A?  带头结点的单链表为空:head->next==NULL;不带头结点的单链表为空head==NULL
12.C
13.D
14.A
15.D
16.B
17.D
18.D
19.C  A 带尾指针的链表在末尾删除元素不方便,找不到前驱 使用带头结点的双循环链表就可以
20.D
21.C
22.C
23.C  D 看清题目 排序说ACB 问的是ABC的顺序
24.B
25.B  D 当带头结点的循环单链表长度是0是 也有head->next->next->...next->next=head
1.线性表
    (1)顺序存储--顺序表
    (2)链式存储
        指针实现:
        [1]单链表
        [2]双链表
        [3]循环链表
        借助数组实现:
        静态链表
2.L=(a1,a2,...an)
  a1是第一个元素,即表头元素
  a2是最后一个元素,即表尾元素
  元素有限
3.线性表是一种逻辑结构,表示元素之间意义的相邻关系
  顺序表和链表是指存储结构
4.线性表的基本操作
    (1)InitList(&L); 初始化表,构造一个空的线性表
    (2)Length(L):求表长.返回线性表L的长度,即L中的数据元素的个数
    (3)LocateElem(L,e)按值查找,在表中查找具有给定关键字值的元素
    (4)GetElem(L,i)按位查找操作,获取表L中第i个位置的元素的值
    (5)ListInsert(&L,i,e)插入操作,在表L中的第i个位置上插入指定元素e
    (6)ListDelete(&L,i,&e)删除操作,删除表中第i个位置的元素,并用e返回删除元素的值
    (7)PrintList(L)输出操作,按前后顺序输出线性表L的所有元素值
    (8)DestoryList(&L)销毁操作,销毁线性表,并释放线性表L所占用的内存空间
单选题
1.C
2.A?B? 线性表是一个序列:即元素之间有前驱后继关系
3.A
5.顺序表
线性表的顺序存储成为顺序表:用一组连续的存储单元一次存储线性表中的元素,从而使得逻辑上相邻的两个元素在物理位置上也相邻
顺序表的逻辑顺序与其物理顺序相同
数组下表                   顺序表                       内存地址
0                           a1                         LOC(A)
1                           a2                         LOC(A)+sizeof(ElemType)

                           ....
i-1                         ai                         LOC(A)+(i-1)*sizeof(ElemType)
                           ....

n-1                         an                         LOC(A)+(n-1)*sizeof(ElemType)


MaxSize-1                   aMaxSize                   LOC(A)+(MaxSize-1)*sizeof(ElemType)
其中:线性表中的元素位序是从1开始的,而数组中元素的下表是从0开始的
6.动态分配并不是链式存储,它同样属于顺序存储结构,物理结构没有变化,依然是随机存取而方式,指示分配的空间大小可以在运行时动态决定
7.顺序表最主要的特点是随机访问,即通过首地址和元素序号在时间O(1)内赵鼎制定的元素
8.顺序表存储密度高,每个结点只存储数据元素
9.顺序表逻辑上相邻的元素,物理上也相邻,所以插入和删除操作需要移动大量元素
10.L的最后一个元素是L.data[L.length-1] 因为L.data[是从0开始的]
11.线性表插入元素的效率:
    (1)最好情况:在表尾插入(即i=n+1),元素后移语句将不执行,时间复杂度为O(1)
    (2)最坏情况,在表头插入即(i=1),元素后移语句将执行n次,时间复杂度为O(n)
    (3)平均情况,假设pi(pi=1/(n+1))是在第i个位置上插入一个结点的概率,则在长度为n的线性表插入一个节点
       所需移动节点的平均次数是n/2,时间复杂度为O(n)
12.线性表删除元素
    (1)最好情况:删除表尾元素(即i=n),无需移动元素,时间复杂度为O(1)
    (2)最坏情况,删除在表头即(i=1),元素前移语句将执行n-1次,时间复杂度为O(n)
    (3)平均情况,假设pi(pi=1/(n))删除第i个位置上结点的概率,则在长度为n的线性表删除一个节点
       所需移动节点的平均次数是(n-1)/2,时间复杂度为O(n)
13.线性表按值查找
    (1)最好情况:寻找的元素在表头元素,仅需比较一次,时间复杂度为O(1)
    (2)最坏情况,查找的元素在表尾或不在表内,需要比较n次,时间复杂度为O(n)
    (3)平均情况,假设pi(pi=1/(n))是,查找的元素在第i个位置上的概率则平均比较次数
       是(n+1)/2,时间复杂度为O(n)
单选题
1.A
2.A
3.B
4.D
5.A
6.C
7.C
8.C
9.C
10.B
11.D

14.顺序表:顺序表中的“顺序”是物理意义上的，指线形表中的元素一个接一个的存储在一片相邻的存储区域中
   有序表:有序表中的“有序”是逻辑意义上的有序，指表中的元素按某种规则已经排好了位置


15.单链表：线性表链式存储
   通过一组任意的存储单元来存储线性表中的数据元素
   为了建立数据之间的线性关系，对每个链表节点，除存放元素自身的信息外，还需要存放一个指向其后继的指针
16.通常用头指针来标识一个单链表，如单链表L，头指针为NULL时表示一个空表
   在单链表第一个结点之前附加一个结点，称为头结点，头结点的数据域可以不设任何信息，也可以记录表长等
   L-->|///| *--|->  | a1 | *--|-> | a2 | *--|-> ....
17.:头节点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头节点是带头结点的链表中的第一个结点
18.引入头结点之后
  (1)由于第一个数据结点的位置被存放在头结点的指针域中,因此在链表的的第一个位置上的操作和在表的其他位置上的操作一致
  (2)无论链表是否为空,其头指针都是非空指针(空表中头结点的指针域为空)因此空表和飞控表的处理也得到了统一
19.循环单链表
表尾结点指针*r的next域指向L，故表中没有指针域为NULL的结点
判断循环单链表上是否为空的条件是头结点的指针是否等于头指针
20.循环双链表
   (1)循环双链表中，头结点的prior指针指向表尾结点
   (2)在循环双链表L中，若某结点*p为尾结点时,p->next==L;
   (3)当循环双链表为空时，其头结点的prior域和next域都等于L
21.静态链表
   (1)借助数组来描述线性表的链式存储结构
   (2)也有数据域data和指针域next,这里的指针时结点的相对地址(数组下标)，又称游标
   (3)和顺序表一样,静态链表也要预先分配一块连续的内存空间
22.静态链表以next==-1作为其结束的标志
   静态链表的插入、删除操作与动态链表相同,只需要修改指针,不需要移动元素
   静态链表没有单链表使用方便,但是在不支持指针的情况下,是一种奇妙的设计
23.顺序表和链表的比较
1.存取(读写)方式
   (1)顺序表可以顺序存取,也可以随机存取,链表只能从表头顺序存取元素。
   (2)采用顺序存储时,逻辑上相邻的元素,对应的物理存储位置也相邻
2.采用链式存储时,逻辑上相邻的元素,物理存储位置不一定相邻,对应的逻辑关系是通过指针链接来表示的
3.查找、插入和删除操作
   按值查找,顺序表无序时,两者的时间复杂度均为O(n);顺序表有序时,可以采用折半查找,时间复杂度为O(logn)
4.空间分配
   (1)顺序存储在静态存储分配情形下,一旦存储空间装满就不能扩充,若再加入新元素,则会出现内存溢出,
   因此需要预先分配足够大的存储空间,但预先分配过大,可能会导致顺序表后部大量闲置;预先分配过小,又会造成溢出
   (2)采用动态存储分配虽然存储空间可以扩充,但需要移动大量元素,导致操作效率低,而且若内存中没有
   更大块的连续存储空间,则会导致分配失败
   (3)链式存储的结点空间只在需要时申请分配,只要内存有空间就可以分配,操作灵活且高效
5.如何选取存储结构
   (1)基于存储的考虑
   难以估计线性表的长度或存储规模时,不宜采用顺序表;链表不用事先估计存储规模,
   但链表的存储密度低
   (2)基于运算的考虑
   顺序表中方位ai的时间复杂度是O(1),而链表是O(n),因此若常做按序号访问数据元素的操作,顺序表优于链表
   在顺序表中进行插入、删除操作时,平均移动表中一半的元素,当数据元素的信息量较大且表长时,链表优于顺序表
   虽然链表查找插入位置会费时
   (3)基于环境的考虑
   顺序表容易实现,任何高级语言中都有数组类型;而链表的生死线是基于指针的

单选题
1.B
2.B
3.C
4.D
5.B  A 删除元素链表不用移动很多元素 效率高 在最后一个元素后插入一个元素,顺序表效率高(不考虑内存不够)
6.C
7.B  D 数组排序的时间复杂度是O(nlogn)+插入的复杂度O(n)=O(nlogn)
8.A  C 插到链表最后面的时间复杂度是O(n),因为要找到这个元素的时间复杂度是O(n)
9.B C? 增加头结点的目的是方便运算
10.B
11.A?  带头结点的单链表为空:head->next==NULL;不带头结点的单链表为空head==NULL
12.C
13.D
14.A
15.D
16.B
17.D
18.D
19.C  A 带尾指针的链表在末尾删除元素不方便,找不到前驱 使用带头结点的双循环链表就可以
20.D
21.C
22.C
23.C  D 看清题目 排序说ACB 问的是ABC的顺序
24.B
25.B  D 当带头结点的循环单链表长度是0是 也有head->next->next->...next->next=head